import { deployments, ethers, getNamedAccounts } from "hardhat";

import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { ContractTransaction } from "ethers";
import { expect } from "chai";
import { Exchange, MockDAI, MockWETH, SimpleFillOrder, SimpleSwap, TopStakers } from "../../typechain-types";
import { ERC_20_ABI } from "../../utils/constants";
import { getNetworkInfo, sleep } from "../../utils/network";

describe("Exchange Module tests", function () {
    let trx;
    let tx: ContractTransaction;
    let deployerSigner: SignerWithAddress;
    let adminSigner: SignerWithAddress;
    let userSigner: SignerWithAddress;
    let user2Signer: SignerWithAddress;
    let botSigner: SignerWithAddress;

    let DAI: MockDAI;
    let WETH: MockWETH;

    let simpleSwap: SimpleSwap;
    let exchangeModule: Exchange;
    let simpleFillOrder: SimpleFillOrder;
    let topStakers: TopStakers;
    let constants: ConstantsType;

    const getWETHandDAI = async (wethAmount: number, wethToSwap: number, signer: SignerWithAddress) => {
        const wethBalanceBefore = await WETH.balanceOf(signer.address);
        const daiBalanceBefore = await DAI.balanceOf(signer.address);
        if (wethBalanceBefore.gt(BN_1E18) && daiBalanceBefore.gt(BN_1E18)) {
            return;
        }
        // @ts-ignore
        const deposit = await WETH.connect(signer).deposit({
            value: ethers.utils.parseEther(wethAmount.toString()),
        });
        await deposit.wait();

        /* Execute the swap */
        await WETH.connect(signer).approve(simpleSwap.address, ethers.utils.parseEther(wethToSwap.toString()));
        const amountIn = ethers.utils.parseEther(wethToSwap.toString());
        const swap = await simpleSwap.connect(signer).swapWETHForDAI(amountIn);
        await swap.wait();

        /* Check DAI end balance */
        const wethBalance = await WETH.balanceOf(signer.address);
        expect(wethBalance).to.be.gte(BN_1E18.mul(wethAmount - wethToSwap));
        const daiBalance = await DAI.balanceOf(signer.address);
        expect(daiBalance).to.be.gt(BN_1E18);
        console.log("DAI balance:", Number(ethers.utils.formatUnits(daiBalance, constants.DAI.decimals)));
        console.log("WETH balance:", Number(ethers.utils.formatUnits(wethBalance, 18)));
    };

    const beforeAllFunc = async () => {
        const { deployer, admin, userAccount, randomAccount, alice } = await getNamedAccounts();
        const networkName = await getNetworkInfo();
        // This test are only for mainnet!
        if (networkName !== "sepolia") return;

        deployerSigner = await ethers.getSigner(deployer);
        adminSigner = await ethers.getSigner(admin);
        userSigner = await ethers.getSigner(userAccount);
        user2Signer = await ethers.getSigner(alice);
        botSigner = await ethers.getSigner(randomAccount);

        constants = getConstants(networkName) as ConstantsType;

        WETH = new ethers.Contract(constants.WETH.address, ERC_20_ABI, deployerSigner) as MockWETH;
        DAI = new ethers.Contract(constants.DAI.address, ERC_20_ABI, deployerSigner) as MockDAI;

        await deployments.fixture(["Core", "Oracle"]);

        exchangeModule = (await ethers.getContract("Exchange")) as Exchange;
        topStakers = (await ethers.getContract("TopStakers")) as TopStakers;
        simpleSwap = (await ethers.getContract("SimpleSwap")) as SimpleSwap;
        simpleFillOrder = (await ethers.getContract("SimpleFillOrder")) as SimpleFillOrder;

        await getWETHandDAI(5, 1, userSigner);
    };

    describe("Fill order not a top staker", function () {
        this.beforeEach(beforeAllFunc);

        it("Add order + FULL fill order, not a top staker", async () => {
            await getWETHandDAI(2, 2, botSigner);
            const wethAmount = BN_1E18;

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            const balanceDAIUser1 = await DAI.balanceOf(userSigner.address);
            const balanceWETHUser1 = await WETH.balanceOf(userSigner.address);
            const balanceDAIBot1 = await DAI.balanceOf(botSigner.address);
            const balanceWETHBot1 = await WETH.balanceOf(botSigner.address);

            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();
            const [{ orderId, order }] = await exchangeModule.getAllOrders();

            const orderAmount = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            expect(await DAI.balanceOf(botSigner.address)).to.be.gt(orderAmount);

            // no approve
            await expect(
                simpleFillOrder.connect(botSigner).fillOrderSimple(orderId, order.token2sell, order.amountLeft)
            ).to.be.reverted;

            await DAI.connect(botSigner).approve(simpleFillOrder.address, orderAmount.mul(2));

            // not a top staker
            // await expect(
            //     simpleFillOrder.connect(botSigner).fillOrderSimple(orderId, order.token2sell, order.amountLeft)
            // ).to.be.reverted;

            await waitAndMine(duration.minutes(1));
            tx = await simpleFillOrder.connect(botSigner).fillOrderSimple(orderId, order.token2sell, order.amountLeft);

            const balanceDAIUser2 = await DAI.balanceOf(userSigner.address);
            const balanceWETHUser2 = await WETH.balanceOf(userSigner.address);
            const balanceDAIBot2 = await DAI.balanceOf(botSigner.address);
            const balanceWETHBot2 = await WETH.balanceOf(botSigner.address);

            expect(balanceWETHUser1.sub(balanceWETHUser2)).to.be.eq(wethAmount);
            expect(balanceWETHBot2.sub(balanceWETHBot1)).to.be.eq(wethAmount);

            // ~ orderAmount - discount amount from a few seconds
            expect(balanceDAIUser2).to.be.gte(balanceDAIUser1.add(orderAmount.sub(BN_1E18)));
            expect(balanceDAIBot2).to.be.gte(balanceDAIBot1.sub(orderAmount.add(BN_1E18)));

            expect(await exchangeModule.getOrdersCount()).to.be.eq(0);
        });
    });

    describe("AddOrder", function () {
        this.beforeAll(beforeAllFunc);

        it("Has no allowance", async () => {
            trx = exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, BN_1E18, DAI.address, userSigner.address, 1);
            await expect(trx).to.be.reverted;
        });

        it("Can't sell more than in balance", async () => {
            const balanceBefore = await WETH.balanceOf(userSigner.address);
            const wethAmount = balanceBefore.add(1);

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);

            trx = exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await expect(trx).to.be.reverted;
        });

        it("Has allowance", async () => {
            const wethAmount = BN_1E18;

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            const balanceBefore = await WETH.balanceOf(userSigner.address);

            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();

            expect(await exchangeModule.getOrdersCount()).to.be.eq(1);
            const [{ orderId, order }] = await exchangeModule.getAllOrders();
            expect(orderId).to.be.gt(0);
            expect(order.amountLeft).to.be.eq(wethAmount);
            expect(order.token2sell.toLowerCase()).to.be.eq(WETH.address.toLowerCase());
            expect(order.token2buy.toLowerCase()).to.be.eq(DAI.address.toLowerCase());
            expect(order.token2buyAmount).to.be.eq(0);
            expect(order.beneficiary).to.be.eq(userSigner.address);
            expect(order.discountType).to.be.eq(1);
            expect(order.creationTimestamp).to.be.eq(await latest());

            const balanceAfter = await WETH.balanceOf(userSigner.address);
            expect(balanceBefore.sub(balanceAfter)).to.be.eq(wethAmount);

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();
            expect(await exchangeModule.getOrdersCount()).to.be.eq(2);
            expect((await exchangeModule.getAllOrders()).length).to.be.eq(2);
        });
    });

    describe("getExpectedOrderOutcome", function () {
        this.beforeAll(beforeAllFunc);

        it("test time", async () => {
            const wethAmount = BN_1E18;

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 0);
            await tx.wait();
            const [{ orderId, order }] = await exchangeModule.getAllOrders();

            const out1 = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            await waitAndMine(1);
            const out2 = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            expect(out2).to.be.lt(out1);
            await waitAndMine(10);
            const out3 = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            expect(out3).to.be.lt(out2);

            // end of increase time in aggressive discount time
            await waitAndMine(600 * 5 - 10);
            const out4 = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            expect(out4).to.be.lt(out3);
            await waitAndMine(10);
            const out5 = await exchangeModule.getExpectedOrderOutcome(orderId, order.amountLeft);
            expect(out5).to.be.eq(out4);

            await sleep(1000);
        });
    });

    describe("Cancel order", function () {
        this.beforeAll(beforeAllFunc);

        it("Cancel order work well", async () => {
            const wethAmount = BN_1E18;

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            const balance1 = await WETH.balanceOf(userSigner.address);

            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();
            const [{ orderId: oldOrderId }] = await exchangeModule.getAllOrders();

            tx = await exchangeModule.connect(userSigner).cancelOrder(oldOrderId);
            await tx.wait();

            const balance2 = await WETH.balanceOf(userSigner.address);

            expect(balance2).to.be.eq(balance1);
            expect(await exchangeModule.getOrdersCount()).to.be.eq(0);
        });

        it("Cancel order call twice", async () => {
            const wethAmount = BN_1E18;

            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            const balance1 = await WETH.balanceOf(userSigner.address);

            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();
            const [{ orderId: oldOrderId }] = await exchangeModule.getAllOrders();
            tx = await exchangeModule.connect(userSigner).cancelOrder(oldOrderId);
            await tx.wait();

            // check that after cancel new addOrder work well
            await WETH.connect(userSigner).approve(exchangeModule.address, wethAmount);
            tx = await exchangeModule
                .connect(userSigner)
                .addOrder(WETH.address, wethAmount, DAI.address, userSigner.address, 1);
            await tx.wait();
            const [{ orderId: newOrderId }] = await exchangeModule.getAllOrders();

            expect(newOrderId).not.to.be.eq(oldOrderId);

            const balance2 = await WETH.balanceOf(userSigner.address);
            expect(balance1.sub(balance2)).to.be.eq(wethAmount);

            trx = exchangeModule.connect(userSigner).cancelOrder(oldOrderId);
            await expect(trx).to.be.reverted;
            tx = await exchangeModule.connect(userSigner).cancelOrder(newOrderId);
            await tx.wait();

            const balance4 = await WETH.balanceOf(userSigner.address);

            expect(balance4).to.be.eq(balance1);
            expect(await exchangeModule.getOrdersCount()).to.be.eq(0);
        });
    });
});
